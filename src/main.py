# -*- coding: utf-8 -*-
"""
# main.py
This module serves as the entry point for the Sudoku Solver application.
It initializes the application, sets up logging, and starts the main event loop.

All (nearly) of the doc strings in this Sudoku Solver application was automatically generated by ChatGPT via copilot.
I only pressed tab. It blew my freaking mind.
"""

import argparse
import logging
import sys


def main():
    """
    Main function to start the Sudoku Solver application.
    Initializes the application, sets up the main window, and starts the event loop.
    This function also sets up logging for the application.
    """

    # Set up logging
    inArgs = parseArgs()
    uiLogger = setupLogging(loggingLevel=inArgs.loglevel)
    uiLogger.info("Starting Sudoku Solver Application")
    uiLogger.debug("Setting up application environment")

    # Parse command line arguments
    uiLogger.debug("Parsing command line arguments") 

    # Import necessary PyQt modules
    from PyQt6.QtWidgets import QApplication

    uiLogger.debug("Importing QApplication from PyQt6.QtWidgets")
    from ui.uiMainWindow import AppMainWindow

    uiLogger.debug("Importing AppMainWindow from ui.uiMainWindow")
    # Initialize the application
    uiLogger.debug("Initializing QApplication")

    app = QApplication(sys.argv)
    app.setApplicationName("SudokuSolverApp")
    app.setApplicationVersion("1.0.0")
    uiLogger.debug("Application initialized with name and version")

    appStyle = "Fusion"
    uiLogger.debug(f"Setting application style to {appStyle}")
    app.setStyle(appStyle)

    uiLogger.debug("Creating AppMainWindow instance")
    # Create the main window instance
    MainWindow = AppMainWindow(lang=inArgs.language)
    uiLogger.debug(f"AppMainWindow created with language: {inArgs.language}")
    uiLogger.debug("Displaying the main window")
    # Show the main window
    MainWindow.show()

    sys.exit(app.exec())

def setupLogging(loggingLevel="INFO") -> logging.Logger:
    """Set up logging for the application.
    This function configures the logging settings, including the format and level of logging.
    It creates a logger that can be used throughout the application.
    Returns:
        logging.Logger: The configured logger instance.
    """

    logging.addLevelName(
        logging.INFO, "\033[1;37m%-8s\033[1;0m" % logging.getLevelName(logging.INFO)
    )
    logging.addLevelName(
        logging.DEBUG, "\033[1;32m%-8s\033[1;0m" % logging.getLevelName(logging.DEBUG)
    )
    logging.addLevelName(
        logging.WARNING, "\033[33m%-8s\033[1;0m" % logging.getLevelName(logging.WARNING)
    )
    logging.addLevelName(
        logging.ERROR, "\033[1;31m%-8s\033[1;0m" % logging.getLevelName(logging.ERROR)
    )
    FORMAT = "%(levelname)s\033[1;34m%(module)s:%(funcName)s\033[0m -> %(message)s\t\033[30m(%(filename)s[%(lineno)d])\033[0m"
    logging.basicConfig(
        format=FORMAT,
        level=logging.__dict__[loggingLevel.upper()],
        handlers=[logging.StreamHandler(sys.stdout)],
    )
    uiLogger = logging.getLogger("uiLogger")
    uiLogger.debug("Logging is set up")
    return uiLogger


def parseArgs() -> argparse.Namespace:
    """Parse command line arguments.
    This function is a placeholder for future command line argument parsing.
    Currently, it does not implement any functionality.
    """

    # Placeholder for command line argument parsing
    parser = argparse.ArgumentParser(
        description="Sudoku Solver Application",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        add_help=True,
        allow_abbrev=True,
        prog="SudokuSolverApp",
        epilog="something something dark side",
        usage="%(prog)s [options]",
    )
    parser.add_argument(
        "-l",
        "--language",
        type=str,
        default="python",
        choices=["python", "julia", "luajit", "lua"],
        help="Set the runtime language for the solver (default: python). This option allows you to choose the programming language used for solving Sudoku puzzles. Supported languages are Python, Julia, LuaJIT, and Lua.",
    )

    parser.add_argument(
        "--loglevel",
        type=str,
        default="debug",
        choices=["debug", "info", "warning", "error", "critical"],
        help="Set the logging level (default: info). This option allows you to control the verbosity of the application logs. Choose from debug, info, warning, error, or critical.",
    )

    parser.add_argument(
        "-v",
        "--version",
        action="version",
        version="%(prog)s 1.0.0",
        help="Show the application version and exit. This option displays the current version of the Sudoku Solver application and exits.",
    )

    args = parser.parse_args()
    return args

class CustomFormatter(logging.Formatter):
    green = "\033[32m"    
    grey = "\033[37m"
    yellow = "\033[33m"
    red = "\033[31m"
    bold_red = "\033[31m"
    reset = "\033[1m"
    format = "%(levelname)8s %(module)25s->%(funcName)-12s %(message)-30s"

    FORMATS = {
        logging.DEBUG: green + format + reset,
        logging.INFO: grey + format + reset,
        logging.WARNING: yellow + format + reset,
        logging.ERROR: red + format + reset,
        logging.CRITICAL: bold_red + format + reset,
    }

    def format(self, record):
        
        log_fmt = self.FORMATS.get(record.levelno)
        formatter = logging.Formatter(log_fmt)
        return formatter.format(record)

if __name__ == "__main__":
    main()
